// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: logpattern.proto

package logpattern_go_proto

import (
	fmt "fmt"
	io "io"
	math "math"
	math_bits "math/bits"

	proto "github.com/gogo/protobuf/proto"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// The path a package in a repo
type PackagePath struct {
	// repo name
	// e.g. "tidb", "tikv", "github.com/pingcap/tidb"
	Repo string `protobuf:"bytes,1,opt,name=repo,proto3" json:"repo,omitempty"`
	// the path relative to repo root e.g. "pkg/util"
	Path string `protobuf:"bytes,2,opt,name=path,proto3" json:"path,omitempty"`
}

func (m *PackagePath) Reset()         { *m = PackagePath{} }
func (m *PackagePath) String() string { return proto.CompactTextString(m) }
func (*PackagePath) ProtoMessage()    {}
func (*PackagePath) Descriptor() ([]byte, []int) {
	return fileDescriptor_9a35be2004e1e167, []int{0}
}
func (m *PackagePath) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PackagePath) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PackagePath.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PackagePath) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PackagePath.Merge(m, src)
}
func (m *PackagePath) XXX_Size() int {
	return m.Size()
}
func (m *PackagePath) XXX_DiscardUnknown() {
	xxx_messageInfo_PackagePath.DiscardUnknown(m)
}

var xxx_messageInfo_PackagePath proto.InternalMessageInfo

func (m *PackagePath) GetRepo() string {
	if m != nil {
		return m.Repo
	}
	return ""
}

func (m *PackagePath) GetPath() string {
	if m != nil {
		return m.Path
	}
	return ""
}

// A Position represents a unique location within a repo.
type Position struct {
	PackagePath *PackagePath `protobuf:"bytes,1,opt,name=package_path,json=packagePath,proto3" json:"package_path,omitempty"`
	// A path-structured label describing the location of this object relative to
	// the repo. For code, this will generally be the relative
	// path to the file containing the log, e.g., "dm/dm-master/service.go" in dm.
	FilePath string `protobuf:"bytes,2,opt,name=file_path,json=filePath,proto3" json:"file_path,omitempty"`
	// The line number containing the position, 1-based.
	LineNumber int32 `protobuf:"varint,3,opt,name=line_number,json=lineNumber,proto3" json:"line_number,omitempty"`
	// The byte offset of the position within its line.
	ColumnOffset int32 `protobuf:"varint,4,opt,name=column_offset,json=columnOffset,proto3" json:"column_offset,omitempty"`
}

func (m *Position) Reset()         { *m = Position{} }
func (m *Position) String() string { return proto.CompactTextString(m) }
func (*Position) ProtoMessage()    {}
func (*Position) Descriptor() ([]byte, []int) {
	return fileDescriptor_9a35be2004e1e167, []int{1}
}
func (m *Position) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Position) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Position.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Position) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Position.Merge(m, src)
}
func (m *Position) XXX_Size() int {
	return m.Size()
}
func (m *Position) XXX_DiscardUnknown() {
	xxx_messageInfo_Position.DiscardUnknown(m)
}

var xxx_messageInfo_Position proto.InternalMessageInfo

func (m *Position) GetPackagePath() *PackagePath {
	if m != nil {
		return m.PackagePath
	}
	return nil
}

func (m *Position) GetFilePath() string {
	if m != nil {
		return m.FilePath
	}
	return ""
}

func (m *Position) GetLineNumber() int32 {
	if m != nil {
		return m.LineNumber
	}
	return 0
}

func (m *Position) GetColumnOffset() int32 {
	if m != nil {
		return m.ColumnOffset
	}
	return 0
}

// Function information
type FuncInfo struct {
	// The function name
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// Function definied position
	Pos *Position `protobuf:"bytes,2,opt,name=pos,proto3" json:"pos,omitempty"`
	// Function code
	Code []byte `protobuf:"bytes,3,opt,name=code,proto3" json:"code,omitempty"`
}

func (m *FuncInfo) Reset()         { *m = FuncInfo{} }
func (m *FuncInfo) String() string { return proto.CompactTextString(m) }
func (*FuncInfo) ProtoMessage()    {}
func (*FuncInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_9a35be2004e1e167, []int{2}
}
func (m *FuncInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FuncInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FuncInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FuncInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FuncInfo.Merge(m, src)
}
func (m *FuncInfo) XXX_Size() int {
	return m.Size()
}
func (m *FuncInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_FuncInfo.DiscardUnknown(m)
}

var xxx_messageInfo_FuncInfo proto.InternalMessageInfo

func (m *FuncInfo) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *FuncInfo) GetPos() *Position {
	if m != nil {
		return m.Pos
	}
	return nil
}

func (m *FuncInfo) GetCode() []byte {
	if m != nil {
		return m.Code
	}
	return nil
}

// A LogPattern represents a log in code file
type LogPattern struct {
	// log position
	Pos *Position `protobuf:"bytes,1,opt,name=pos,proto3" json:"pos,omitempty"`
	// The function this log belongs to
	Func *FuncInfo `protobuf:"bytes,2,opt,name=func,proto3" json:"func,omitempty"`
	// used to quickly identify the log,
	// e.g. the `format` field of Printf(format string, v ...interface{}) in golang
	CodeSignature []string `protobuf:"bytes,3,rep,name=code_signature,json=codeSignature,proto3" json:"code_signature,omitempty"`
}

func (m *LogPattern) Reset()         { *m = LogPattern{} }
func (m *LogPattern) String() string { return proto.CompactTextString(m) }
func (*LogPattern) ProtoMessage()    {}
func (*LogPattern) Descriptor() ([]byte, []int) {
	return fileDescriptor_9a35be2004e1e167, []int{3}
}
func (m *LogPattern) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LogPattern) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LogPattern.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LogPattern) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LogPattern.Merge(m, src)
}
func (m *LogPattern) XXX_Size() int {
	return m.Size()
}
func (m *LogPattern) XXX_DiscardUnknown() {
	xxx_messageInfo_LogPattern.DiscardUnknown(m)
}

var xxx_messageInfo_LogPattern proto.InternalMessageInfo

func (m *LogPattern) GetPos() *Position {
	if m != nil {
		return m.Pos
	}
	return nil
}

func (m *LogPattern) GetFunc() *FuncInfo {
	if m != nil {
		return m.Func
	}
	return nil
}

func (m *LogPattern) GetCodeSignature() []string {
	if m != nil {
		return m.CodeSignature
	}
	return nil
}

func init() {
	proto.RegisterType((*PackagePath)(nil), "logcov.proto.logpattern.PackagePath")
	proto.RegisterType((*Position)(nil), "logcov.proto.logpattern.Position")
	proto.RegisterType((*FuncInfo)(nil), "logcov.proto.logpattern.FuncInfo")
	proto.RegisterType((*LogPattern)(nil), "logcov.proto.logpattern.LogPattern")
}

func init() { proto.RegisterFile("logpattern.proto", fileDescriptor_9a35be2004e1e167) }

var fileDescriptor_9a35be2004e1e167 = []byte{
	// 351 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x94, 0x8f, 0xcd, 0x4a, 0xeb, 0x40,
	0x14, 0xc7, 0x3b, 0xb7, 0xbd, 0x97, 0xf6, 0xa4, 0xbd, 0x5c, 0x72, 0x17, 0x06, 0x84, 0x58, 0xa3,
	0x42, 0x37, 0x66, 0xd1, 0xd2, 0x17, 0x70, 0xa1, 0x08, 0xa2, 0x61, 0xdc, 0xb9, 0x09, 0xd3, 0x38,
	0x99, 0x06, 0xd3, 0x39, 0x43, 0x32, 0xf1, 0x39, 0x7c, 0x03, 0xdf, 0xc2, 0x67, 0x70, 0xd9, 0xa5,
	0x4b, 0x69, 0x5f, 0x44, 0x66, 0xd2, 0xd0, 0x6e, 0x8a, 0xb8, 0xca, 0xc9, 0x6f, 0xce, 0xf9, 0x7f,
	0xc0, 0xbf, 0x1c, 0x85, 0x62, 0x5a, 0xf3, 0x42, 0x86, 0xaa, 0x40, 0x8d, 0xee, 0x41, 0x8e, 0x22,
	0xc1, 0xe7, 0xfa, 0x2f, 0xdc, 0x3e, 0x07, 0x53, 0x70, 0x22, 0x96, 0x3c, 0x31, 0xc1, 0x23, 0xa6,
	0xe7, 0xae, 0x0b, 0x9d, 0x82, 0x2b, 0xf4, 0xc8, 0x90, 0x8c, 0x7a, 0xd4, 0xce, 0x86, 0x29, 0xa6,
	0xe7, 0xde, 0xaf, 0x9a, 0x99, 0x39, 0x78, 0x23, 0xd0, 0x8d, 0xb0, 0xcc, 0x74, 0x86, 0xd2, 0xbd,
	0x82, 0xbe, 0xaa, 0x35, 0x62, 0xbb, 0x68, 0x8e, 0x9d, 0xf1, 0x69, 0xb8, 0xc7, 0x33, 0xdc, 0x31,
	0xa4, 0x8e, 0xda, 0x71, 0x3f, 0x84, 0x5e, 0x9a, 0xe5, 0x1b, 0x95, 0xda, 0xae, 0x6b, 0x80, 0x7d,
	0x3c, 0x02, 0x27, 0xcf, 0x24, 0x8f, 0x65, 0xb5, 0x98, 0xf1, 0xc2, 0x6b, 0x0f, 0xc9, 0xe8, 0x37,
	0x05, 0x83, 0x6e, 0x2d, 0x71, 0x4f, 0x60, 0x90, 0x60, 0x5e, 0x2d, 0x64, 0x8c, 0x69, 0x5a, 0x72,
	0xed, 0x75, 0xec, 0x4a, 0xbf, 0x86, 0x77, 0x96, 0x05, 0x02, 0xba, 0x97, 0x95, 0x4c, 0xae, 0x65,
	0x6a, 0x8b, 0x49, 0xb6, 0xe0, 0x4d, 0x59, 0x33, 0xbb, 0x13, 0x68, 0x2b, 0x2c, 0xad, 0xb9, 0x33,
	0x3e, 0xde, 0x5f, 0x61, 0xd3, 0x9d, 0x9a, 0x6d, 0x23, 0x94, 0xe0, 0x23, 0xb7, 0x99, 0xfa, 0xd4,
	0xce, 0xc1, 0x2b, 0x01, 0xb8, 0x41, 0x11, 0xd5, 0x07, 0x8d, 0x2e, 0xf9, 0x91, 0xee, 0x14, 0x3a,
	0x69, 0x25, 0x93, 0x6f, 0xd3, 0x34, 0x8d, 0xa8, 0x5d, 0x77, 0xcf, 0xe0, 0xaf, 0x89, 0x10, 0x97,
	0x99, 0x90, 0x4c, 0x57, 0x85, 0x09, 0xd6, 0x1e, 0xf5, 0xe8, 0xc0, 0xd0, 0xfb, 0x06, 0x5e, 0x9c,
	0xbf, 0xaf, 0x7c, 0xb2, 0x5c, 0xf9, 0xe4, 0x73, 0xe5, 0x93, 0x97, 0xb5, 0xdf, 0x5a, 0xae, 0xfd,
	0xd6, 0xc7, 0xda, 0x6f, 0x3d, 0xfc, 0xdf, 0x6a, 0xc7, 0x02, 0x63, 0xeb, 0x37, 0xfb, 0x63, 0x3f,
	0x93, 0xaf, 0x00, 0x00, 0x00, 0xff, 0xff, 0x40, 0x37, 0x47, 0x0b, 0x5d, 0x02, 0x00, 0x00,
}

func (m *PackagePath) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PackagePath) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PackagePath) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Path) > 0 {
		i -= len(m.Path)
		copy(dAtA[i:], m.Path)
		i = encodeVarintLogpattern(dAtA, i, uint64(len(m.Path)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Repo) > 0 {
		i -= len(m.Repo)
		copy(dAtA[i:], m.Repo)
		i = encodeVarintLogpattern(dAtA, i, uint64(len(m.Repo)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Position) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Position) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Position) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ColumnOffset != 0 {
		i = encodeVarintLogpattern(dAtA, i, uint64(m.ColumnOffset))
		i--
		dAtA[i] = 0x20
	}
	if m.LineNumber != 0 {
		i = encodeVarintLogpattern(dAtA, i, uint64(m.LineNumber))
		i--
		dAtA[i] = 0x18
	}
	if len(m.FilePath) > 0 {
		i -= len(m.FilePath)
		copy(dAtA[i:], m.FilePath)
		i = encodeVarintLogpattern(dAtA, i, uint64(len(m.FilePath)))
		i--
		dAtA[i] = 0x12
	}
	if m.PackagePath != nil {
		{
			size, err := m.PackagePath.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintLogpattern(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *FuncInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FuncInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FuncInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Code) > 0 {
		i -= len(m.Code)
		copy(dAtA[i:], m.Code)
		i = encodeVarintLogpattern(dAtA, i, uint64(len(m.Code)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Pos != nil {
		{
			size, err := m.Pos.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintLogpattern(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintLogpattern(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *LogPattern) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LogPattern) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LogPattern) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.CodeSignature) > 0 {
		for iNdEx := len(m.CodeSignature) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.CodeSignature[iNdEx])
			copy(dAtA[i:], m.CodeSignature[iNdEx])
			i = encodeVarintLogpattern(dAtA, i, uint64(len(m.CodeSignature[iNdEx])))
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.Func != nil {
		{
			size, err := m.Func.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintLogpattern(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Pos != nil {
		{
			size, err := m.Pos.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintLogpattern(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintLogpattern(dAtA []byte, offset int, v uint64) int {
	offset -= sovLogpattern(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *PackagePath) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Repo)
	if l > 0 {
		n += 1 + l + sovLogpattern(uint64(l))
	}
	l = len(m.Path)
	if l > 0 {
		n += 1 + l + sovLogpattern(uint64(l))
	}
	return n
}

func (m *Position) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PackagePath != nil {
		l = m.PackagePath.Size()
		n += 1 + l + sovLogpattern(uint64(l))
	}
	l = len(m.FilePath)
	if l > 0 {
		n += 1 + l + sovLogpattern(uint64(l))
	}
	if m.LineNumber != 0 {
		n += 1 + sovLogpattern(uint64(m.LineNumber))
	}
	if m.ColumnOffset != 0 {
		n += 1 + sovLogpattern(uint64(m.ColumnOffset))
	}
	return n
}

func (m *FuncInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovLogpattern(uint64(l))
	}
	if m.Pos != nil {
		l = m.Pos.Size()
		n += 1 + l + sovLogpattern(uint64(l))
	}
	l = len(m.Code)
	if l > 0 {
		n += 1 + l + sovLogpattern(uint64(l))
	}
	return n
}

func (m *LogPattern) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Pos != nil {
		l = m.Pos.Size()
		n += 1 + l + sovLogpattern(uint64(l))
	}
	if m.Func != nil {
		l = m.Func.Size()
		n += 1 + l + sovLogpattern(uint64(l))
	}
	if len(m.CodeSignature) > 0 {
		for _, s := range m.CodeSignature {
			l = len(s)
			n += 1 + l + sovLogpattern(uint64(l))
		}
	}
	return n
}

func sovLogpattern(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozLogpattern(x uint64) (n int) {
	return sovLogpattern(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *PackagePath) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLogpattern
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PackagePath: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PackagePath: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Repo", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLogpattern
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLogpattern
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthLogpattern
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Repo = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Path", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLogpattern
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLogpattern
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthLogpattern
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Path = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipLogpattern(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthLogpattern
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Position) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLogpattern
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Position: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Position: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PackagePath", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLogpattern
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLogpattern
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthLogpattern
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PackagePath == nil {
				m.PackagePath = &PackagePath{}
			}
			if err := m.PackagePath.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FilePath", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLogpattern
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLogpattern
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthLogpattern
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FilePath = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LineNumber", wireType)
			}
			m.LineNumber = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLogpattern
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LineNumber |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ColumnOffset", wireType)
			}
			m.ColumnOffset = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLogpattern
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ColumnOffset |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipLogpattern(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthLogpattern
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FuncInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLogpattern
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FuncInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FuncInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLogpattern
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLogpattern
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthLogpattern
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pos", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLogpattern
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLogpattern
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthLogpattern
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Pos == nil {
				m.Pos = &Position{}
			}
			if err := m.Pos.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLogpattern
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthLogpattern
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthLogpattern
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Code = append(m.Code[:0], dAtA[iNdEx:postIndex]...)
			if m.Code == nil {
				m.Code = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipLogpattern(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthLogpattern
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LogPattern) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLogpattern
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LogPattern: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LogPattern: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pos", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLogpattern
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLogpattern
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthLogpattern
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Pos == nil {
				m.Pos = &Position{}
			}
			if err := m.Pos.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Func", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLogpattern
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLogpattern
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthLogpattern
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Func == nil {
				m.Func = &FuncInfo{}
			}
			if err := m.Func.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CodeSignature", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLogpattern
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthLogpattern
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthLogpattern
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CodeSignature = append(m.CodeSignature, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipLogpattern(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthLogpattern
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipLogpattern(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowLogpattern
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowLogpattern
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowLogpattern
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthLogpattern
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupLogpattern
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthLogpattern
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthLogpattern        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowLogpattern          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupLogpattern = fmt.Errorf("proto: unexpected end of group")
)
